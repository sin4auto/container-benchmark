# ワークフローの名前
name: C++ CI

# ワークフローが実行されるタイミングを指定
on:
  # mainブランチにプッシュされたとき
  push:
    branches: [ "main" ]
  # プルリクエストが作成されたとき
  pull_request:
    branches: [ "main" ]

# 実行する一連のタスク（ジョブ）を定義
jobs:
  # ジョブの名前（ここでは build-and-run）
  build-and-run:
    # ジョブを実行する仮想環境の種類（Ubuntuの最新版）
    runs-on: ubuntu-latest

    # ジョブの具体的な手順（ステップ）
    steps:
      # 1. リポジトリのコードを仮想環境にチェックアウトする
      - uses: actions/checkout@v4

      # 2. コードをコンパイルする
      - name: Compile the benchmark
        # READMEに記載されているコマンドを実行
        run: g++ -o benchmark vector_deque_list.cpp -std=c++17 -O2

      # 3. コンパイルされたプログラムを実行する
      - name: Run the benchmark
        run: ./benchmark```

**解説:**
*   `on: [push, pull_request]`: `main`ブランチにコードがプッシュされたり、`main`ブランチに対してプルリクエストが作られたりするたびに、このワークフローが自動で実行されます。
*   `runs-on: ubuntu-latest`: この処理は、GitHubが用意してくれるLinux（Ubuntu）環境上で実行されます。
*   `steps:`: 実行されるコマンドを上から順に定義しています。
    1.  `actions/checkout@v4`: リポジトリのコードを仮想マシンに持ってくるための定型句です。
    2.  `Compile the benchmark`: `README.md`に記載のコマンドで`vector_deque_list.cpp`をコンパイルします。コンパイルに失敗すれば、ここでCIは失敗します。
    3.  `Run the benchmark`: コンパイルが成功したら、生成された実行ファイル`benchmark`を実行します。プログラムがエラーで終了（クラッシュなど）すれば、ここでCIは失敗します。

#### ステップ3: ファイルをコミット＆プッシュ

この`ci.yml`ファイルをリポジトリに追加してコミットし、GitHubにプッシュしてください。

### 4. 導入後の確認

プッシュが完了すると、自動的にCIが実行されます。

*   リポジトリのタブから**「Actions」**を選択すると、ワークフローの実行状況が確認できます。
*   実行が成功すると、緑色のチェックマーク ✅ が付きます。
*   ワークフロー名をクリックすると、コンパイルやベンチマーク実行時のログ（出力結果）を詳細に確認できます。

### （おまけ）READMEにステータスバッジを追加する

CIが一度でも成功したら、`README.md`にバッジを追加して、プロジェクトの健全性をアピールしましょう。

1.  **「Actions」**タブで、成功したワークフローをクリックします。
2.  右上に「Create status badge」というボタンがあるのでクリックします。
3.  表示されたMarkdownコードをコピーして、`README.md`の好きな場所（通常はタイトルの直後）に貼り付けます。

---

まずはこの基本的なCIを導入するだけで、プロジェクトの信頼性と開発の安定性が大きく向上します。ここからさらに、複数のコンパイラ（Clang）やOS（Windows/macOS）でテストするような、より高度な設定に発展させることも可能です。